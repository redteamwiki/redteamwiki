---
title: Mimikatz - Mimidrv
description: Mimi Driver reference
published: true
date: 2025-10-08T17:53:08.516Z
tags: mimikatz
editor: markdown
dateCreated: 2025-10-08T17:53:08.516Z
---

# Mimikatz - Mimidrv

mimidrv driver documentation

## Overview
`mimidrv` is the optional kernel-mode driver that powers the commands behind Mimikatz's `kernel` helper module.  It exposes kernel information (processes, modules, callbacks, SSDT, file-system filters) and privileged primitives (token duplication, process protection, kernel memory read/write) through a device object that user-mode code can reach via standard `DeviceIoControl` calls.  The driver creates the `\\Device\\mimidrv` device and a `\\DosDevices\\mimidrv` symbolic link, and registers a `IRP_MJ_DEVICE_CONTROL` dispatch routine for all supported IOCTLs when it loads.【F:mimidrv/mimidrv.c†L6-L166】  User-mode code inside Mimikatz routes any command that starts with `!` to this driver via `kuhl_m_kernel_do`, which parses the command name and optional `/flag:value` arguments before issuing the matching IOCTL.【F:mimikatz/mimikatz.c†L149-L165】【F:mimikatz/modules/kuhl_m_kernel.c†L8-L54】

> **Safety notice** – Loading unsigned kernel drivers requires disabling Secure Boot or using test-signing, and the commands below directly manipulate kernel data structures.  Use them only in lab environments where crashing or destabilizing the OS is acceptable.

## Building the driver
### Prerequisites
* Visual Studio (2010–2019) with the solution in the repository.
* Windows Driver Kit (WDK) 7.1 (WinDDK 7600.16385.1) for the `mimidrv` project.  The rest of Mimikatz builds without the WDK, but the driver relies on it.【F:README.md†L107-L115】

### Building from Visual Studio
1. Open `mimikatz.sln` inside Visual Studio on a machine that has WDK 7.1 installed.
2. Select the desired configuration (`Win32` or `x64`) and build the solution; Visual Studio invokes the `_build_.cmd` helper for the driver project.  If the WDK is missing you will see MSBuild error `MSB3073` referencing `_build_.cmd`—installing WDK 7.1 resolves it.【F:README.md†L107-L115】

### Building from the command prompt
The `mimidrv/_build_.cmd` script automates a WDK build using the legacy `build.exe` environment.

```cmd
cd mimidrv
_build_.cmd Win32 ..\bin
```

* The first argument chooses the Visual Studio platform (`Win32` or `x64`); the script maps it to the WDK architecture directories (`x86/i386` or `amd64/amd64`).【F:mimidrv/_build_.cmd†L6-L16】
* The script locates the WDK at `%SystemDrive%\WinDDK\7600.16385.1`, runs `setenv.bat` to initialize the environment, calls `build`, and copies the resulting `.sys` file into the destination folder you pass as the second argument.【F:mimidrv/_build_.cmd†L4-L25】
* Temporary `obj` and architecture folders are removed after the build to keep the tree clean.【F:mimidrv/_build_.cmd†L26-L27】

## Installing and uninstalling the driver
1. Place the built `mimidrv.sys` next to `mimikatz.exe`.
2. Launch Mimikatz with administrative privileges and ensure driver signature enforcement is disabled if you are using an unsigned build.
3. Inside the Mimikatz console run `!+`.  The command resolves the absolute path to `mimidrv.sys` and installs or starts a kernel-service named `mimidrv` through the Service Control Manager.【F:mimikatz/modules/kuhl_m_kernel.c†L56-L68】
4. When you are done, run `!-` to uninstall the service entry and unload the driver.【F:mimikatz/modules/kuhl_m_kernel.c†L70-L74】

If Mimikatz cannot locate the `.sys` file or SCM operations fail, the helper prints the relevant Windows error code, allowing you to troubleshoot path or privilege issues.【F:mimikatz/modules/kuhl_m_kernel.c†L62-L66】

## Issuing commands from Mimikatz
* All driver-backed commands begin with `!` and are parsed by `kuhl_m_kernel_do`.  Unknown commands fall back to `IOCTL_MIMIDRV_RAW`, which currently just echoes a "not implemented" message.【F:mimikatz/mimikatz.c†L149-L165】【F:mimikatz/modules/kuhl_m_kernel.c†L30-L54】
* Flags follow the conventional Mimikatz syntax `/flag:value`.  Boolean switches (for example `/remove`) are present or absent; they do not take values unless specified below.【F:mimikatz/modules/kuhl_m_kernel.c†L82-L206】

### Command reference
Each section lists the syntax, supported flags, what the command does, and when to use it.

#### `!+` — install or start `mimidrv`
* **Flags:** none.
* **Effect:** Locates `mimidrv.sys`, installs it as a kernel service if necessary, and starts it.【F:mimikatz/modules/kuhl_m_kernel.c†L56-L68】
* **Why:** Required before any other driver-backed command will work.  It ensures the device `\\.\mimidrv` exists so subsequent IOCTLs succeed.【F:modules/kull_m_kernel.c†L44-L75】

#### `!-` — remove the driver
* **Flags:** none.
* **Effect:** Stops and deletes the `mimidrv` service entry, unloading the driver.【F:mimikatz/modules/kuhl_m_kernel.c†L70-L74】
* **Why:** Cleans up after testing and avoids leaving an unsigned driver registered.

#### `!ping`
* **Flags:** none.
* **Effect:** Sends `IOCTL_MIMIDRV_PING` and prints the input string alongside a `pong` response, verifying the control path between user mode and the driver.【F:mimidrv/mimidrv.c†L79-L158】
* **Why:** Quick connectivity test before issuing sensitive operations.

#### `!bsod`
* **Flags:** none.
* **Effect:** Triggers `KeBugCheck(MANUALLY_INITIATED_CRASH)` through `IOCTL_MIMIDRV_BSOD`.【F:mimidrv/mimidrv.c†L87-L89】
* **Why:** Demonstrates the driver's level of privilege or forces a crash dump for forensic testing.  Use only in sacrificial environments.

#### `!process`
* **Flags:** none.
* **Effect:** Enumerates every EPROCESS in the active process list and prints the PID, image name, token freeze state, and signature protection levels when available.【F:mimidrv/mimidrv.c†L97-L105】【F:mimidrv/kkll_m_process.c†L32-L68】
* **Why:** Helps identify protected processes (PPL/PsProtected) and frozen tokens before attempting privilege operations.

#### `!processProtect`
* **Flags:**
  * `/process:<image>` – resolve the process ID by image name.【F:mimikatz/modules/kuhl_m_kernel.c†L84-L89】
  * `/pid:<id>` – target a specific PID when the image name is ambiguous.【F:mimikatz/modules/kuhl_m_kernel.c†L90-L94】
  * `/remove` – remove protection instead of applying it.【F:mimikatz/modules/kuhl_m_kernel.c†L82-L124】
* **Effect:** Builds a `MIMIDRV_PROCESS_PROTECT_INFORMATION` structure with protection levels suited to the current Windows build, then sets or clears the target's protection fields inside EPROCESS.【F:mimikatz/modules/kuhl_m_kernel.c†L95-L124】【F:mimidrv/ioctl.h†L50-L58】【F:mimidrv/kkll_m_process.c†L69-L118】
* **Why:** Allows you to promote a user process to a protected process (mimicking PPL) to defend it from tampering, or to remove protection so you can debug or inject into system binaries.

#### `!processToken`
* **Flags:**
  * `/from:<pid>` – PID to copy the token from (0 defaults to the SYSTEM process).【F:mimikatz/modules/kuhl_m_kernel.c†L134-L143】
  * `/to:<pid>` – PID to receive the duplicated token (0 applies to every `cmd.exe` and `mimikatz.exe`).【F:mimikatz/modules/kuhl_m_kernel.c†L137-L144】
* **Effect:** Opens the source process token and duplicates it into the destination process(es) or every tracked console window if `/to:0` is used.【F:mimikatz/modules/kuhl_m_kernel.c†L140-L147】【F:mimidrv/kkll_m_process.c†L120-L176】
* **Why:** Escalates privileges of a user shell by seizing SYSTEM or another process token without spawning new processes, which is less noisy than full process creation.

#### `!processPrivilege`
* **Flags:** `/pid:<id>` – optional; when omitted the command targets all tracked shells and Mimikatz instances.【F:mimikatz/modules/kuhl_m_kernel.c†L152-L160】
* **Effect:** Calls `IOCTL_MIMIDRV_PROCESS_FULLPRIV`, which clears privilege restrictions and enables every privilege bit in the target process token.【F:mimikatz/modules/kuhl_m_kernel.c†L151-L160】【F:mimidrv/mimidrv.c†L103-L108】
* **Why:** Prepares a process for operations that require rarely-used privileges (e.g., `SeDebugPrivilege`) without editing the token manually.

#### `!modules`
* **Flags:** none.
* **Effect:** Enumerates all loaded kernel modules, printing base addresses, sizes, and full paths by querying `AuxKlibQueryModuleInformation`.【F:mimidrv/mimidrv.c†L110-L112】【F:mimidrv/kkll_m_modules.c†L8-L33】
* **Why:** Verifies that a module is loaded and shows its load address for use in subsequent memory operations or callback tracing.

#### `!ssdt`
* **Flags:** none.
* **Effect:** Dumps the SSDT (System Service Descriptor Table), resolving each entry back to the owning module by scanning the service table for function addresses.【F:mimidrv/mimidrv.c†L114-L116】【F:mimidrv/kkll_m_ssdt.c†L12-L42】
* **Why:** Detects system call hooks or verifies that SSDT entries point into legitimate modules.

#### `!notifProcess`, `!notifThread`, `!notifImage`, `!notifReg`, `!notifObject`
* **Flags:** none.
* **Effect:** For each notification type, the driver locates the OS-specific callback arrays or lists and prints registered callbacks with their owning module addresses.【F:mimidrv/mimidrv.c†L118-L133】【F:mimidrv/kkll_m_notify.c†L8-L200】
* **Why:** Investigates kernel callbacks that may enforce security products, inject code, or monitor system activity.

#### `!filters`
* **Flags:** none.
* **Effect:** Lists legacy file-system filter drivers returned by `IoEnumerateRegisteredFiltersList`, including driver names.【F:mimidrv/mimidrv.c†L134-L136】【F:mimidrv/kkll_m_filters.c†L50-L70】
* **Why:** Identifies installed minifilter-style defenses that might intercept file operations.

#### `!minifilters`
* **Flags:** none.
* **Effect:** Enumerates modern file-system minifilters, their instances, attached volumes, and per-IRP callbacks, resolving callback addresses to modules.【F:mimidrv/mimidrv.c†L137-L139】【F:mimidrv/kkll_m_filters.c†L106-L194】
* **Why:** Maps advanced filter drivers, including security products, so you can determine which callbacks to disable or monitor.

#### `!sysenvset`
* **Flags:**
  * `/name:<variable>` – EFI variable name (default `Kernel_Lsa_Ppl_Config`).【F:mimikatz/modules/kuhl_m_kernel.c†L173-L210】
  * `/guid:<GUID>` – Vendor GUID in braces (default `{77fa9abd-0359-4d32-bd60-28f4e78f784b}`).【F:mimikatz/modules/kuhl_m_kernel.c†L173-L206】
  * `/attributes:<hex>` – EFI attribute mask (default `1`).【F:mimikatz/modules/kuhl_m_kernel.c†L173-L206】
  * `/data:<hexbytes>` – Hex-encoded payload (default `00000000`).【F:mimikatz/modules/kuhl_m_kernel.c†L173-L207】
* **Effect:** Converts the parameters into a `MIMIDRV_VARIABLE_NAME_AND_VALUE` buffer, prints a summary, and sends it to `ZwSetSystemEnvironmentValueEx` through the driver so the EFI variable is created or updated.【F:mimikatz/modules/kuhl_m_kernel.c†L195-L207】【F:mimidrv/ioctl.h†L68-L75】【F:mimidrv/mimidrv.c†L47-L58】
* **Why:** Modifies secure-boot protected variables (for example toggling LSA Protection) without rebooting into firmware tools.

#### `!sysenvdel`
* **Flags:** `/name`, `/guid`, `/attributes` – same defaults as `!sysenvset`.【F:mimikatz/modules/kuhl_m_kernel.c†L225-L257】
* **Effect:** Builds a variable descriptor with zero-length data and sends it via `IOCTL_MIMIDRV_SYSENVSET`, which causes `ZwSetSystemEnvironmentValueEx` to delete the variable if the attributes match.【F:mimikatz/modules/kuhl_m_kernel.c†L233-L253】【F:mimidrv/mimidrv.c†L93-L95】
* **Why:** Cleans up EFI variables added during testing or removes policy controls enforced through EFI.

### Fallback `!` commands
Any `!something` that does not match the table above is forwarded as a raw Unicode string to `IOCTL_MIMIDRV_RAW`, which currently just echoes that the command is unimplemented.  This makes it safe to experiment without triggering undefined behavior.【F:mimikatz/modules/kuhl_m_kernel.c†L40-L52】【F:mimidrv/mimidrv.c†L81-L84】

## Programmatic IOCTL reference
Developers who want to call the driver from custom tooling can use the IOCTL codes defined in `mimidrv/ioctl.h`.  All codes use `METHOD_NEITHER` and require administrator access to open `\\.\mimidrv`.【F:mimidrv/ioctl.h†L6-L75】【F:modules/kull_m_kernel.c†L8-L77】

| Category | IOCTL | Purpose | Why use it |
| --- | --- | --- | --- |
| Diagnostics | `IOCTL_MIMIDRV_PING`, `IOCTL_MIMIDRV_DEBUG_BUFFER`, `IOCTL_MIMIDRV_RAW` | Connectivity test, buffer introspection, or placeholder passthroughs for future expansion.【F:mimidrv/mimidrv.c†L81-L92】 | Validate handle access, inspect driver buffer handling, or prototype new commands without recompiling the driver. |
| Stability testing | `IOCTL_MIMIDRV_BSOD` | Invokes `KeBugCheck`.【F:mimidrv/mimidrv.c†L87-L89】 | Force crash dumps or test blue-screen monitoring setups. |
| System configuration | `IOCTL_MIMIDRV_SYSENVSET` | Set or delete EFI variables.【F:mimidrv/mimidrv.c†L93-L95】 | Persist configuration changes across boots, such as LSA protection flags. |
| Process management | `IOCTL_MIMIDRV_PROCESS_LIST`, `IOCTL_MIMIDRV_PROCESS_PROTECT`, `IOCTL_MIMIDRV_PROCESS_TOKEN`, `IOCTL_MIMIDRV_PROCESS_FULLPRIV` | Enumerate processes, toggle protection, duplicate tokens, or grant all privileges.【F:mimidrv/mimidrv.c†L97-L108】【F:mimidrv/ioctl.h†L13-L16】 | Collect intelligence on protected processes or perform privilege escalation primitives. |
| Module and SSDT insight | `IOCTL_MIMIDRV_MODULE_LIST`, `IOCTL_MIMIDRV_SSDT_LIST` | List loaded modules and dump SSDT entries.【F:mimidrv/mimidrv.c†L110-L116】 | Detect hooks and locate driver entry points. |
| Callback inventory | `IOCTL_MIMIDRV_NOTIFY_*`, `IOCTL_MIMIDRV_FILTER_LIST`, `IOCTL_MIMIDRV_MINIFILTER_LIST` | Enumerate process/thread/image/registry/object callbacks and file-system filters.【F:mimidrv/mimidrv.c†L118-L139】 | Map third-party monitoring components that could hinder red-team activity. |
| Memory primitives | `IOCTL_MIMIDRV_VM_READ`, `IOCTL_MIMIDRV_VM_WRITE`, `IOCTL_MIMIDRV_VM_ALLOC`, `IOCTL_MIMIDRV_VM_FREE` | MDL-backed read/write, allocation, and free in kernel memory.【F:mimidrv/mimidrv.c†L141-L151】【F:mimidrv/kkll_m_memory.c†L17-L90】 | Implement direct kernel memory manipulation for advanced implants or diagnostics. |
| Threading | `IOCTL_MIMIDRV_CREATEREMOTETHREAD` | Calls a function pointer supplied from user mode in kernel context.【F:mimidrv/mimidrv.c†L153-L155】【F:mimidrv/ioctl.h†L36-L67】 | Experimental primitive for invoking custom kernel payloads after mapping them into the driver's address space. |

### Buffer semantics
Because all IOCTLs use `METHOD_NEITHER`, callers must supply user-mode pointers directly.  The driver uses MDLs (`IoAllocateMdl`, `MmProbeAndLockPages`) to safely copy kernel memory for read/write requests and allocates pool memory for kernel outputs where necessary.【F:mimidrv/mimidrv.c†L71-L160】【F:mimidrv/kkll_m_memory.c†L17-L78】  When an IOCTL returns textual data, Mimikatz allocates the output buffer automatically and prints the UTF-16 stream character by character before freeing it.【F:modules/kull_m_kernel.c†L64-L77】  When writing your own tooling, mirror this pattern to avoid leaks and ensure buffers are large enough.

## Unloading and cleanup
The driver's `DriverUnload` routine deletes the symbolic link and device object, so unloading through `!-` or the Service Control Manager removes user-mode access to `\\.\mimidrv`.【F:mimidrv/mimidrv.c†L16-L20】  Always unload the driver when finished to restore the system to its original state.

